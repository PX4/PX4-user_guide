# Poor Man's Sampling Profiler

Цей розділ описує, як ви можете використовувати [Poor Man's Sampling Profiler](https://github.com/PX4/PX4-Autopilot/blob/main/platforms/nuttx/Debug/poor-mans-profiler.sh) (PMSP) shell script для оцінки продуктивності PX4. Це реалізація відомого методу, яку спочатку винайшли [Марк Callaghan і Domas Mituzas](https://poormansprofiler.org/).

## Підхід

PMSP - це оболонковий сценарій, який працює шляхом переривання виконання прошивки періодично для збору поточного стеку викликів. Відмічені трасування стеку додаються в текстовий файл. Після завершення вибірки (що зазвичай займає близько години або більше), зібрані стек-відстеження _згортаються_. Результатом _складання_ є інший текстовий файл, який містить ті ж стекові відстеження, за винятком того, що всі схожі стекові відстеження (тобто ті, які були отримані в тій же точці в програмі) об'єднуються, і фіксується кількість їх випадків. Згорнуті стеки потім подаються в сценарій візуалізації, для цього ми використовуємо [FlameGraph - візуалізатор відкритого вихідного коду стеку викликів](http://www.brendangregg.com/flamegraphs.html).

## Базове використання

### Передумови

Профілер покладається на GDB для запуску PX4 на вбудованій цілі. Так що перед профілюванням цілі, вам потрібно мати обладнання, яке ви хочете профілювати, і вам потрібно скомпілювати та завантажити прошивку на це обладнання. Вам потрібно мати [зонд для налагодження](../debug/swd_debug.md#debug-probes) (такий як зонд DroneCode), щоб запустити сервер GDB та взаємодіяти з платою.

### Визначення пристрою відладки

`poor-mans-profiler.sh` автоматично виявляє та використовує правильний USB-пристрій, якщо ви використовуєте його з [DroneCode Probe](../debug/probe_bmp.md#dronecode-probe). Якщо ви використовуєте інший тип зонда, можливо, вам потрібно буде передати конкретний _пристрій_, на якому знаходиться відлагоджувач. Ви можете використовувати команду bash `ls -alh /dev/serial/by-id/` для переліку можливих пристроїв на Ubuntu. Наприклад, наступні пристрої перераховані з підключеними через USB Pixhawk 4 та DroneCode Probe:

```sh
user@ubuntu:~/PX4-Autopilot$ ls -alh /dev/serial/by-id/
total 0
drwxr-xr-x 2 root root 100 Apr 23 18:57 .
drwxr-xr-x 4 root root  80 Apr 23 18:48 ..
lrwxrwxrwx 1 root root  13 Apr 23 18:48 usb-3D_Robotics_PX4_FMU_v5.x_0-if00 -> ../../ttyACM0
lrwxrwxrwx 1 root root  13 Apr 23 18:57 usb-Black_Sphere_Technologies_Black_Magic_Probe_BFCCB401-if00 -> ../../ttyACM1
lrwxrwxrwx 1 root root  13 Apr 23 18:57 usb-Black_Sphere_Technologies_Black_Magic_Probe_BFCCB401-if02 -> ../../ttyACM2
```

У цьому випадку скрипт автоматично вибере пристрій з назвою `*Black_Magic_Probe*-if00`. Але якщо ви використовуєте інший пристрій, ви зможете знайти відповідний ідентифікатор у вищезазначеному переліку.

Потім передайте відповідний пристрій, використовуючи аргумент `--gdbdev`, як показано нижче:

```sh
./poor-mans-profiler.sh --elf=build/px4_fmu-v4_default/px4_fmu-v4_default.elf --nsamples=30000 --gdbdev=/dev/ttyACM2
```

### Запуск

Основне використання профілера доступне через систему збірки. Наприклад, наступні командні збірки та профілі px4_fmu-v4pro ціль із 10000 зразками (отримання _FlameGraph_ і додавання його до шляху, як це необхідно).

```sh
make px4_fmu-v4pro_default profile
```

Для більшого контролю над процесом побудови, включаючи встановлення кількості вибірок, див. [Реалізація](#implementation).

## Розуміння виводу

Знизу наведено знімок екрану прикладового виводу (зверніть увагу, що тут він не є інтерактивним):

![FlameGraph Example](../../assets/debug/flamegraph-example.png)

На графіку пламені, горизонтальні рівні представляють рамки стеку, тоді як ширина кожної рамки пропорційна кількості разів, коли вона була вибрана. Зі свого боку, кількість разів, коли функцію виявилися вибраною, пропорційна тривалості множеній на частоту її виконання.

## Можливі проблеми

Сценарій був розроблений як тимчасове рішення, тому він має деякі проблеми. Будь ласка, будьте обережні з ними під час використання:

- Якщо GDB працює некоректно, скрипт може не виявити це і продовжити виконання. У цьому випадку, очевидно, не буде вироблено жодних придатних стеків. Щоб уникнути цього, користувач повинен періодично перевіряти файл `/tmp/pmpn-gdberr. og`, який містить stderr вихід останнього покликання GDB. У майбутньому сценарій слід змінити так, щоб він викликав GDB у тихому режимі, де він буде вказувати проблеми через свій код виходу.

- Іноді GDB просто залишається назавжди, поки відбувається вибіркове збереження стеку. Під час цієї несправності ціль буде припинена на невизначений термін. Рішення полягає вручну переривати скрипт і знову запускати його з опцією `--append`. У майбутньому сценарій слід змінити, щоб накладати тайм-аут на кожне викликання GDB.

- Багатопотокові середовища не підтримуються. Це не впливає на однопроцесорні вбудовані цілі, оскільки вони завжди виконуються в одному потоці, але це обмеження робить профілер несумісним з багатьма іншими програмами. У майбутньому папку стеку слід модифікувати для підтримки кількох стеків викликів на один зразок.

## Реалізація

Сценарій розташований за посиланням [/platforms/nuttx/Debug/poor-mans-profiler.sh](https://github.com/PX4/PX4-Autopilot/blob/main/platforms/nuttx/Debug/poor-mans-profiler.sh) Після запуску він виконає вказану кількість вибірок із вказаним інтервалом часу. Зібрані зразки будуть збережені в текстовому файлі у каталозі тимчасових файлів системи (зазвичай `/tmp`). Після завершення вибіркового відбору сценарій автоматично викличе папку стеку, вихід якої буде збережено в сусідньому файлі в тимчасовому каталозі. Якщо стеки були успішно згорнуті, сценарій викличе сценарій _FlameGraph_ та збереже результат у взаємодійному файлі SVG. Зверніть увагу, що не всі переглядачі зображень підтримують інтерактивні зображення; рекомендується відкрити отриманий SVG у веб-переглядачі.

Сценарій FlameGraph повинен знаходитися в `PATH`, інакше PMSP відмовиться запускатися.

PMSP використовує GDB для збору стек-відстежень. На даний момент використовує `arm-none-eabi-gdb`, інші інструментальні набори можуть бути додані у майбутньому.

Для того щоб мати можливість відображати місця розташування пам'яті на символи, сценарій повинен посилатися на виконуваний файл, який в даний момент працює на цільовому пристрої. Це робиться за допомогою опції `--elf=<file>`, яка очікує шлях (відносно кореня сховища), що вказує на місце розташування виконуваного в даний момент ELF.

Приклад використання:

```sh
./poor-mans-profiler.sh --elf=build/px4_fmu-v4_default/px4_fmu-v4_default.elf --nsamples=30000
```

Зверніть увагу, що кожен запуск скрипта перезапише старі стеки. Якщо ви хочете додати до старих стеків замість їх перезапису, скористайтеся опцією `--append`:

```sh
./poor-mans-profiler.sh --elf=build/px4_fmu-v4_default/px4_fmu-v4_default.elf --nsamples=30000 --append
```

Як можна запідозрити, `--append` з `--nsamples=0` буде вказувати скрипту лише регенерувати SVG без доступу до цілі взагалі.

Будь ласка, прочитайте сценарій для більш глибокого розуміння того, як це працює.
